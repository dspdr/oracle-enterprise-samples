import hashlib
import json
import uuid
import logging
import os
from typing import List, Dict, Any
from .models import DecisionPlan, ScenarioResult, DecisionPlanRequest
from .decision import execute_decision_workflow

logger = logging.getLogger("loan_api.planning")

def calculate_inputs_hash(application: Dict, kyc: Dict, fraud: Dict, credit: int, plan_options: Dict) -> str:
    # Canonicalize
    data = {
        "application": application,
        "kyc": kyc,
        "fraud": fraud,
        "credit_score": credit,
        "options": plan_options
    }
    # Sort keys for determinism
    canonical_json = json.dumps(data, sort_keys=True)
    return hashlib.sha256(canonical_json.encode("utf-8")).hexdigest()

def get_scenarios(conn, workspace_id: str, app_id: str, seed: str, count: int, fallback_inputs: Dict) -> List[Dict]:
    # 1. Try DB Native
    scenarios = []
    try:
        # Check if we can use the package (placeholder logic)
        # In a real environment, we would call:
        # cursor.execute("SELECT * FROM TABLE(synthetic_util.generate_scenarios(:1, :2, :3))", [workspace_id, app_id, seed])
        # For this sample, we assume the package returns empty/null as implemented in the stub,
        # so we skip straight to fallback to ensure deterministic behavior in the sample environment.
        pass
    except Exception as e:
        logger.warning(f"Failed to generate DB scenarios: {e}")
    
    if not scenarios:
        # Fallback Python generation (Deterministic)
        scenarios = generate_fallback_scenarios(seed, count, fallback_inputs)
        
    return scenarios

def generate_fallback_scenarios(seed: str, count: int, inputs: Dict) -> List[Dict]:
    # Simple deterministic variations
    # Seed isn't used for crypto randomness here, just to signal intent
    base_income = inputs["application"]["income"]
    base_score = inputs["credit_score"]
    
    results = []
    
    # Scenario 1: Income Down
    s1 = inputs.copy()
    s1["application"] = s1["application"].copy()
    s1["application"]["income"] = base_income * 0.85
    results.append({"name": "income_down_15pct", "inputs": s1})
    
    if count > 1:
        # Scenario 2: Credit Score Down
        s2 = inputs.copy()
        s2["credit_score"] = max(300, base_score - 40)
        results.append({"name": "credit_score_down_40", "inputs": s2})
        
    if count > 2:
         # Scenario 3: Debt Up
        s3 = inputs.copy()
        s3["application"] = s3["application"].copy()
        s3["application"]["debt"] = s3["application"]["debt"] * 1.2
        results.append({"name": "debt_up_20pct", "inputs": s3})

    # Return requested count (loop if needed? No, limiting to 3 for sample)
    return results[:count]

def generate_ai_commentary(conn, plan_data: Dict) -> Dict:
    # Call DBMS_CLOUD_AI to explain the plan
    # "Select AI show me the rationale for this decision..."
    # Fallback to static text if not configured
    
    # In a real impl, we would check if AI profile is set on session and run a query.
    # For now, return mock.
    return {
        "rationale": "Generated by Oracle AI (Mock): The decision is based on strong credit score and low DTI.",
        "risk_factors": ["Economic downturn", "Employment stability"]
    }

def persist_plan(conn, plan: DecisionPlan, idem_key: str):
    cursor = conn.cursor()
    cursor.execute(
        """INSERT INTO decision_plans 
           (plan_id, workspace_id, application_id, idempotency_key, inputs_hash, plan_json, status)
           VALUES (:1, :2, :3, :4, :5, :6, :7)""",
        [plan.plan_id, plan.workspace_id, plan.application_id, idem_key, plan.inputs_hash, plan.model_dump_json(), plan.status]
    )
    conn.commit()
    cursor.close()

def create_plan(conn, app_id: str, app_data: Dict, request: DecisionPlanRequest, idempotency_key: str) -> DecisionPlan:
    # 1. Gather Inputs
    applicant = app_data["applicant_data"]
    decision_data = app_data["decision_data"]
    kyc = decision_data.get("kyc_result", {})
    fraud = decision_data.get("fraud_result", {})
    credit = decision_data.get("credit_score", 0)
    mock_agent = decision_data.get("mock_agent", False)
    
    inputs = {
        "application": {"id": app_id, **applicant},
        "kyc_result": kyc,
        "fraud_result": fraud,
        "credit_score": credit,
        "mock_agent": mock_agent
    }
    
    # Resolve workspace ID first
    ws_id = request.workspace_id or os.environ.get("WORKSPACE_ID_DEFAULT", "default_workspace")

    # 2. Hash
    options_for_hash = {
        "workspace_id": ws_id,
        "scenarios_count": request.scenarios_count
    }
    inputs_hash = calculate_inputs_hash(inputs["application"], kyc, fraud, credit, options_for_hash)
    
    # 3. Base Decision
    base_run_id = str(uuid.uuid5(uuid.NAMESPACE_OID, idempotency_key))
    base_result = execute_decision_workflow(
        {**inputs, "db_conn": conn}, 
        mode="PLAN",
        run_id_base=base_run_id
    )
    
    # 4. Scenarios
    scenarios_data = get_scenarios(conn, ws_id, app_id, idempotency_key, request.scenarios_count, inputs)
    scenario_results = []
    
    for i, s_input in enumerate(scenarios_data):
        s_res = execute_decision_workflow(
            {**s_input["inputs"], "db_conn": conn},
            mode="PLAN",
            run_id_base=f"{base_run_id}_s{i}"
        )
        # Calculate diff inputs for display? 
        # For now just passing the full app object might be heavy, but models.py says inputs: Dict.
        # We'll pass the whole application object as inputs context.
        scenario_results.append(ScenarioResult(
            name=s_input["name"],
            inputs=s_input["inputs"]["application"], 
            decision=s_res["decision"],
            reason_codes=s_res["reason_codes"],
            pricing=s_res["pricing"]
        ))

    # 5. AI Commentary
    commentary = generate_ai_commentary(conn, {"base": base_result, "scenarios": scenario_results})
    
    # 6. Assemble Plan
    plan_id = str(uuid.uuid4())
    plan = DecisionPlan(
        plan_id=plan_id,
        application_id=app_id,
        workspace_id=ws_id,
        run_id=base_run_id,
        inputs_hash=inputs_hash,
        status="CREATED",
        recommended_decision=base_result["decision"],
        reason_codes=base_result["reason_codes"],
        pricing=base_result["pricing"],
        scenario_results=scenario_results,
        ai_commentary=commentary,
        schema_hints={"output_table": "applications"},
        execute_preview=["applications", "audit_logs"]
    )
    
    # 7. Persist Plan
    persist_plan(conn, plan, idempotency_key)
    
    return plan
